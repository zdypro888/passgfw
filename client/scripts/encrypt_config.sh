#!/bin/bash

# Encrypt config.cpp to config_encrypted.cpp
# Reads plaintext config.cpp and generates encrypted version
# 加密 config.cpp 生成 config_encrypted.cpp

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CLIENT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
SOURCE_FILE="${CLIENT_ROOT}/config.cpp"
OUTPUT_FILE="${CLIENT_ROOT}/config_encrypted.cpp"

# Generate random seed for this build
OBFUSCATION_SEED="0x$(od -An -N8 -tx8 /dev/urandom | tr -d ' \n')"

echo "🔐 Encrypting config.cpp..."
echo "   Seed: ${OBFUSCATION_SEED}"

# XOR key generator (matching C++ implementation)
xor_key() {
    local index=$1
    local seed=$2
    
    # Convert hex seed to decimal
    if [[ $seed == 0x* ]]; then
        seed=$((seed))
    fi
    
    # Generate pseudo-random key
    local val=$(( (seed ^ (index * 0x9E3779B97F4A7C15)) & 0xFFFFFFFFFFFFFFFF ))
    val=$(( ((val ^ (val >> 30)) * 0xBF58476D1CE4E5B9) & 0xFFFFFFFFFFFFFFFF ))
    val=$(( ((val ^ (val >> 27)) * 0x94D049BB133111EB) & 0xFFFFFFFFFFFFFFFF ))
    echo $(( (val ^ (val >> 31)) & 0xFF ))
}

# Encrypt string to C array format
encrypt_string() {
    local str="$1"
    local seed="$2"
    local length=${#str}
    local output=""
    
    for ((i=0; i<length; i++)); do
        local char="${str:$i:1}"
        local ascii=$(printf '%d' "'$char")
        local key=$(xor_key $i $seed)
        local encrypted=$(( ascii ^ key ))
        
        # Add comma and newline formatting
        if [ $i -gt 0 ]; then
            output="${output}, "
        fi
        
        # Format: 12 bytes per line
        if [ $((i % 12)) -eq 0 ] && [ $i -ne 0 ]; then
            output="$output\n    "
        fi
        
        output="${output}0x$(printf '%02x' $encrypted)"
    done
    
    echo -e "$output"
}

# Extract URLs from config.cpp
echo "   Extracting URLs..."
URLS=()
while IFS= read -r line; do
    # Match lines like: "http://localhost:8080/passgfw",
    if [[ $line =~ \"([^\"]+)\" ]]; then
        url="${BASH_REMATCH[1]}"
        # Skip empty or comment-only lines
        if [[ -n "$url" && ! "$url" =~ ^[[:space:]]*$ ]]; then
            URLS+=("$url")
        fi
    fi
done < <(sed -n '/GetBuiltinURLs()/,/^}/p' "$SOURCE_FILE" | grep '"')

URL_COUNT=${#URLS[@]}
echo "   Found ${URL_COUNT} URLs"

# Encrypt URLs
ENCRYPTED_URLS=""
URL_LENGTHS=""
URL_OFFSETS=""
current_offset=0

for i in "${!URLS[@]}"; do
    url="${URLS[$i]}"
    length=${#url}
    encrypted=$(encrypt_string "$url" "$OBFUSCATION_SEED")
    
    ENCRYPTED_URLS="${ENCRYPTED_URLS}    // URL ${i}: ${url}\n${encrypted}"
    if [ $i -lt $((URL_COUNT - 1)) ]; then
        ENCRYPTED_URLS="${ENCRYPTED_URLS},\n"
    fi
    
    URL_LENGTHS="${URL_LENGTHS}${length}"
    URL_OFFSETS="${URL_OFFSETS}${current_offset}"
    if [ $i -lt $((URL_COUNT - 1)) ]; then
        URL_LENGTHS="${URL_LENGTHS}, "
        URL_OFFSETS="${URL_OFFSETS}, "
    fi
    
    current_offset=$((current_offset + length))
done

# Extract public key from config.cpp
echo "   Extracting public key..."
PUBLIC_KEY_CONTENT=$(sed -n '/R"(/,/)"$/p' "$SOURCE_FILE" | sed '1d;$d')
PUBLIC_KEY_LENGTH=${#PUBLIC_KEY_CONTENT}
ENCRYPTED_PUBLIC_KEY=$(encrypt_string "$PUBLIC_KEY_CONTENT" "$OBFUSCATION_SEED")

echo "   Public key length: ${PUBLIC_KEY_LENGTH} bytes"

# Generate config_encrypted.cpp
echo "   Generating ${OUTPUT_FILE}..."

cat > "${OUTPUT_FILE}" << EOF
// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by encrypt_config.sh from config.cpp
// This file contains encrypted strings that are decrypted at runtime

#include "config.h"
#include "obfuscation.h"
#include <cstdint>

namespace passgfw {

// Obfuscation seed (generated at build time)
static const uint64_t OBFUSCATION_SEED = ${OBFUSCATION_SEED}ULL;

// Encrypted URL data
static const uint8_t ENCRYPTED_URLS[] = {
$(echo -e "$ENCRYPTED_URLS")
};

static const size_t URL_LENGTHS[] = { ${URL_LENGTHS} };
static const size_t URL_OFFSETS[] = { ${URL_OFFSETS} };
static const size_t URL_COUNT = ${URL_COUNT};

std::vector<std::string> Config::GetBuiltinURLs() {
    return Obfuscation::decrypt_strings(
        ENCRYPTED_URLS,
        URL_LENGTHS,
        URL_OFFSETS,
        URL_COUNT,
        OBFUSCATION_SEED
    );
}

// Encrypted public key data
static const uint8_t ENCRYPTED_PUBLIC_KEY[] = {
    ${ENCRYPTED_PUBLIC_KEY}
};

static const size_t PUBLIC_KEY_LENGTH = ${PUBLIC_KEY_LENGTH};

const char* Config::GetPublicKey() {
    static std::string decrypted_key = Obfuscation::decrypt_string(
        ENCRYPTED_PUBLIC_KEY,
        PUBLIC_KEY_LENGTH,
        OBFUSCATION_SEED
    );
    return decrypted_key.c_str();
}

} // namespace passgfw
EOF

echo "✅ Encryption complete!"
echo "   Source: ${SOURCE_FILE} (plaintext, maintained by you)"
echo "   Output: ${OUTPUT_FILE} (encrypted, auto-generated)"
echo "   URLs: ${URL_COUNT}"
echo "   Public key: ${PUBLIC_KEY_LENGTH} bytes"
echo "   Seed: ${OBFUSCATION_SEED}"

